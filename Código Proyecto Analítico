
# PROYECTO ANALÍTICO en RStudio.
# ------------------------------------

#     Cargar librerías

# 0.- Acceder a la API de twitter
# 1.- Descargar el conjunto de datos
# 2.- Limpieza de los datos
# 3.- Análisis de los datos
# 4.- Representación de los resultados


#   Cargar librerías
# ------------------------------------

# Funciones recursivas, paquete twitter en R, manejo cadena caractéres.
library(plyr)
library(twitteR)
library(stringr)


# 0.- Acceder a la API de twitter
# ------------------------------------

# Cargar fichero externo conteniendo parámetros de acceso a twitter:
# consumer_key, consumer_secret, access_token y access_secret.
source("twitter-auth.R")

# Acceder y conectarse a la API de twitter.
setup_twitter_oauth(Consumer_key, Consumer_secret, Access_token, Access_secret)


# 1.- Descargar el conjunto de datos
# ------------------------------------

# Descargar la lista de tweets del tema de interés.
tweets <- searchTwitter("#Feminismo", n=1000, lang = "es")

# Pasar la lista a data.frame y visualizarla
tweetsDF <- twListToDF(tweets)
View(tweetsDF)

# Número de objetos y de variables
dim(tweetsDF)[1]; dim(tweetsDF)[2]

# Ver la totalidad de las variables
names(tweetsDF)

# Exportar data.frame 1 ORIGINAL a un archivo .csv
write.csv(tweetsDF, file="1-ORIGINAL-tweetsDF.csv")


# 2.- Limpieza de los datos
# ------------------------------------

# FUNCIÓN limpiar tweets
limpiarTweets = function(tweets)
{
  tweets_lm = gsub("(RT|via)((?:\\b\\W*@\\w+)+)","",tweets)
  tweets_lm = gsub("http[^[:blank:]]+", "", tweets_lm)
  tweets_lm = gsub("@\\w+", "", tweets_lm)
  tweets_lm = gsub("[ \t]{2,}", "", tweets_lm)
  tweets_lm = gsub("^\\s+|\\s+$", "", tweets_lm)
  tweets_lm = gsub("[[:punct:]]", " ", tweets_lm)
  tweets_lm = gsub("[^[:alnum:]]", " ", tweets_lm)
  tweets_lm <- gsub('\\d+', '', tweets_lm)
  return(tweets_lm)
}

# Del total de variables del tweet, extraemos solo el campo $text.
tweets_txt=sapply(tweets[1:1000], function(x) x$getText())

# Ejecutar función limpiar tweets.
tweets_txt <- limpiarTweets(tweets_txt)

# Pasar la lista a data.frame y visualizarla
tweets_txtDF <- as.data.frame(tweets_txt)
View(tweets_txtDF)

# Exportar data.frame con solo campo $text, tras limpiar datos, a un archivo .csv
write.csv(tweets_txtDF, file="2-Texto.limpio-tweets_txtDF.csv")


# 3.- Análisis de los datos
# ------------------------------------

# FUNCIÓN para clasificar palabras del texto del tweet, en 4 categorias: 
  # mNeg <- muyNegativo, neg <- negativo, pos <- positivo y mPos <- muyPositivo.
sentimientosScore <- function(frases, mNeg, neg, pos, mPos){
  
  # Inicializar.
  scores_final <- matrix('', 0, 5)
 
  # Devuelve una lista.
  scores <- laply(frases, function(frase, mNeg, neg, pos, mPos){
    frase_inicial <- frase
   
    # Limpieza de los datos eliminando los caracteres innecesarios.
    frase <- limpiarTweets(frase)
    frase <- tolower(frase)
    listaPalabras <- str_split(frase, '\\s+')
    palabras <- unlist(listaPalabras)
   
    # Construye un vector con los emparejamientos (frase versus categorias)
    mPosMatches <- match(palabras, mPos)
    posMatches <- match(palabras, pos)
    mNegMatches <- match(palabras, mNeg)
    negMatches <- match(palabras, neg)
   
    # Suma las palabras por categorias
    mPosMatches <- sum(!is.na(mPosMatches))
    posMatches <- sum(!is.na(posMatches))
    mNegMatches <- sum(!is.na(mNegMatches))
    negMatches <- sum(!is.na(negMatches))
    score <- c(mNegMatches, negMatches, posMatches, mPosMatches)
   
    # Incorpora los resultados agregando una linea a la tabla de puntuaciones
    nlinea <- c(frase_inicial, score)
    scores_final <- rbind(scores_final, nlinea)
    return(scores_final)
  }, mNeg, neg, pos, mPos)
  return(scores)
}


# Cargar la lista de palabras valor. 
afinn_list <- read.csv(file='LISTA-Palabras-Valor.txt', header=FALSE, stringsAsFactors=FALSE)
names(afinn_list) <- c('palabra', 'score')
afinn_list$palabra <- tolower(afinn_list$palabra)

# categorizar las palabras en 4 categorías (de muy negativas a muy positivas).
mNeg <- afinn_list$palabra[afinn_list$score==-5 | afinn_list$score==-4]
neg <- c(afinn_list$palabra[afinn_list$score==-3 | afinn_list$score==-2 | afinn_list$score==-1])
pos <- c(afinn_list$palabra[afinn_list$score==3 | afinn_list$score==2 | afinn_list$score==1])
mPos <- c(afinn_list$palabra[afinn_list$score==5 | afinn_list$score==4])   

# Calcular la puntuación de cada tweet
tweetResultado <- as.data.frame(sentimientosScore(tweets_txt, mNeg, neg, pos, mPos))

# Agregar dos nuevas columnas inicializadas.
tweetResultado <- cbind(tweetResultado,0,'Neutro')

# Dar normbre a las variables
names(tweetResultado)<- c('texto',"muyNeg",'Neg','muyPos','Pos','Valor', 'Sentimiento')

# Pasar a caracter y ponderar
tweetResultado$Sentimiento <- as.character(tweetResultado$Sentimiento)
tweetResultado$Valor <- (-5*as.numeric(tweetResultado$muyNeg) -2.5*as.numeric(tweetResultado$Neg) + 2.5*as.numeric(tweetResultado$Pos) +5*as.numeric(tweetResultado$muyPos))/(as.numeric(tweetResultado$muyNeg)+as.numeric(tweetResultado$Neg)+as.numeric(tweetResultado$muyPos)+as.numeric(tweetResultado$Pos))
tweetResultado$Valor[is.nan(tweetResultado$Valor)] <- 0

# Categorizar resultados en 4 categorías (de muy negativo a muy positivo).
tweetResultado$Sentimiento[tweetResultado$Valor < -1] <- 'Muy Negativo'
tweetResultado$Sentimiento[(tweetResultado$Valor >= -1) & (tweetResultado$Valor < 0)] <- 'Negativo'
tweetResultado$Sentimiento[(tweetResultado$Valor <= 1) & (tweetResultado$Valor > 0)] <- 'Positivo'
tweetResultado$Sentimiento[tweetResultado$Valor > 1] <- 'Muy Positivo'


# 4.- Representación de los resultados
# ------------------------------------

# Creamos una tabla de frecuencias para los 4 sentimientos.
conteo <- as.data.frame(table(tweetResultado$Sentimiento))

# Representación de las valoraciones por sectores.
colores = c("green", "red", "lightyellow", "lightgreen")
pie(conteo$Freq, conteo$Var1, col = colores)
